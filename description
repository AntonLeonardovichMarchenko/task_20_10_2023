Установка инструмента тестирования покрытия coverage - из командной строки:
C:\\Users>pip install coverage

Это вариант модульного тестирования. Эта разновиднось тестирования позволяет делать в рабочей
среде (в среде выполнения приложения? типа в интерпретаторе?) то, что там и делается.
То есть, без лишнего "уродования" кода в интересах тестирования.
Чтобы избежать неожиданных проблем, следует тестировать каждую строку кода создаваемого приложения.
Модульное тестирование также позволяет НЕ останавливать выполнения приложения для тестирования
кода. Так что если настроено модульное тестирование, можно его запускать. И если возникнут какие-либо
ошибки, будет известно, какая часть кода не работает. Покрытие - это инструмент, который может
пригодится при тестировании, поскольку он генерирует отчет и дает процент тестируемого кода,
который был покрыт тестированием. Покрытие можно использовать вместе с unittest и pytest или ещё с
какими либо средствами тестирования (есть и такие). Далеем - описание возможностей средства покрытия.

Исходный код на python: функция, которая при задании имени распечатает инструкцию hello с именем,
но если нет ввода, она распечатает инструкцию hello с именем "Stranger" (типа, незнакомец).
Также имеется код, который запрашивает ввод данных пользователем, а затем передает эти данные функции
для вывода полученной информации.

#tutorial.py
def say_hello(name=None):
    if name != "":
        print("Hello", name)
    else:
        print("Hello Stranger")


if __name__ == "__main__":
    say_hello(input("What is your name? "))

Также имеется файл (моуль) test_tutorial.py, в котором средствами unittest проверяется
функция say_hello (но не всё приложение!). В этом приложении для проведения теста создаётся
специальный класс PrintingTest, которому из модуля tutorial импортируется функция say_hello
и ещё куча всякого хлама, и это всё ради ттого, чтобы проверить, выводит ли эта функция строку
"Hello test" при задании ей при её вызове в качестве аргумента фиксированного имени "QWERTY"
или нет.

#test_tutorial.py
from tutorial import say_hello
from unittest import TestCase
from io import StringIO
from unittest.mock import patch


class PrintingTest(TestCase):

    def test_say_hello(self):
        name = 'QWERTY'
        expected_output = 'Hello {}\n'.format(name)

        with patch('sys.stdout', new=StringIO()) as fake_out:
            say_hello(name)
            self.assertEqual(fake_out.getvalue(), expected_output)

Использование покрытия
Идея состоит в том, чтобы использовать покрытие вместе с тестовым раннером (???)
через командную строку (?).
Несколько примеров.

рytest: если для тестирования используеся pytest, то можно добавить это самое покрытие -m
перед командой запуска pytest. Так:

pytest arg1 arg2 arg3

Это как это будет выглядеть:

coverage run -m pytest arg1 arg2 arg3

если это unittest, то всё, что нужно сделать, это заменить строку запуска приложения
на строку запуска покрытия:

python -m unittest test_code.py

coverage run -m unittest test_code.py

Покрытие будет запускать тестирование и собирать данные. Чтобы просмотреть его как отчет,
надо будет ввести:

coverage report

В результате выполнения всех шагов в коде отчёт будет выглядеть следующим образом:

>coverage run -m unittest test_tutorial.py
.
 — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —
Ran 1 test in 0.001s
OK
>coverage report
Name                 Stmts      Miss      Cover
 — — — — — — — — — — — — — — — — — — — — — — — — —
test_tutorial.py        11          0      100%
tutorial.py              6          2       67%
 — — — — — — — — — — — — — — — — — — — — — — — — —
TOTAL                   17          2       88%

Отдельный вопрос о проценте покрытия. Почему покрытие составляет 88%.
Это потому что у оператора if в модуле tutorial.py есть еще одна ветвь, которая определяет,
что должно происходить в случае "else". Это также должно было бы быть проверено тестами.
Поэтому чтобы охватить эту ветвь, в классе тестирования можно было бы написать и другой метод.
Как то так...:

#test_tutorial.py
class PrintingTest(TestCase):

    .........

    def test_say_hello_noname(self):
        name = ''
        expected_output = 'Hello Stranger\n'

        with patch('sys.stdout', new=StringIO()) as fake_out:
            say_hello(name)
            self.assertEqual(fake_out.getvalue(), expected_output)

Этот второй тест передает пустую строку и проверяет, является ли вывод "Hello Stranger".
Текущее покрытие теперь создает следующий отчет:

>coverage run -m unittest test_tutorial.py
..
 — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —
Ran 2 tests in 0.001s
OK
>coverage report
Name                  Stmts      Miss      Cover
 — — — — — — — — — — — — — — — — — — — — — — — — — — —
test_tutorial.py         17         0       100%
tutorial.py               6         1        83%
 — — — — — — — — — — — — — — — — — — — — — — — — — — —
TOTAL                    23         1        96%

Определенно некоторое улучшение охвата, однако это ещё не 100%.
Причина в том, что фрагмент кода в конце tutorial.py, который запрашивает ввод данных
пользователем и вызывает функцию, не тестируется. Но что, если разработчик не хочет
покрывать это, а также ещё и не хочет, чтобы покрытие включало это в отчет о покрытии
тестами?

В этом случае применяется исключение кода из покрытия: надо добавить "# pragma: no cover".

........

if __name__ == "__main__":
    say_hello(input("What's your name? "))  # pragma: no cover

Если теперь запусть тестирование и ещё раз сгенерить отчет о покрытии, то получится
такой результат:

...........
Name                  Stmts     Miss    Cover
 — — — — — — — — — — — — — — — — — — —— — — — —
test_tutorial.py         17        0     100%
tutorial.py               5        0     100%
 — — — — — — — — — — — — — — — — — — — — — — — —
TOTAL 22 0 100%


А дальше - всякие "прибамбасы"...
Подробный отчет с улучшенным интерфейсом, который предоставляет вам построчную
информацию:

coverage html

Это сгенерирует графический интерфейс в виде веб-страницы. Обычно он сохраняется в папке
с именем "htmlcov" в папке проекта, и для его просмотра откройте файл index.html.
Получается очень подробный отчет, в котором отображается код, который покрыт.

И ещё раз о том, как использовать команду

python unittest coverage

для создания отчета о покрытии тестов.

Что такое покрытие тестов (также известно как покрытие кода)
Покрытие тестов — это соотношение между количеством строк, выполненных хотя бы одним тестовым
примером, и общим количеством строк кодовой базы:

test coverage = lines of code executed / total number of lines

Покрытие тестов применяется для оценки качества набора тестов. Если тестовое покрытие низкое,
например, 5%, это говорит о том, что было проведено "недостаточное" тестирование.
Однако обратное предположение может быть неверно. Например, 100% покрытие тестами не является
гарантией того, что в распоряжении разработчика (тестировщика) имеется "хороший" набор тестов.
Так что, набор тестов с высоким покрытием может быть все еще низкого качества.

Про NumPy. Он будет полезен по крайней мере на примерах.
numpy — это открытая python-библиотека для работы с многомерными массивами (аналог Matlab).
Применяется в анализе данных и обучении нейронных сетей — везде, где нужно проводить много
вычислений с многомерными матрицами.

Перед тем как использовать NumPy, нужно подключить библиотеку в python-коде, так как python
должен узнать, что NumPy будет нужен в данном проекте.

import numpy as np

Далее - о создании многомерных массивов...

Базовые функции

a = np.array([1,2,3], dtype='int32')   # дополнительный параметр, который задаёт
                                       # тип элементов в массиве

ndim - чтобы узнать, сколько у массива измерений
shape - чтобы узнать количество строк и столбцов
size - чтобы узнать количество элементов в массиве
itemsize - чтобы узнать, какое количество байт в памяти занимает один элемент
nbytes - чтобы узнать, какое количество байт занимает весь массив

Короче,
= NumPy — это библиотека для эффективной работы с массивами любого размера.
  Она достигает высокой производительности, потому что написана частично на C и C++ и в
  ней соблюдается принцип локальности — она хранит все элементы последовательно в одном месте.
= Перед тем как использовать NumPy в коде, его нужно подключить с помощью команды
  import numpy as np.
= Основа NumPy — массив. Чтобы его создать, нужно использовать функцию array и передать туда
  список в качестве первого аргумента. Вторым аргументом через dtype можно указать тип для ВСЕХ
  элементов — например, int16 или float32. По умолчанию для целых чисел указывается int32, а для
  десятичных — float64.
= Функция ndim позволяет узнать, сколько измерений у массива;
          shape — его структуру (сколько столбцов и строк);
          dtype — какой тип у элементов;
          size — количество элементов;
          itemsize — сколько байтов занимает один элемент;
          nbytes — сколько всего памяти занимает массив.
= К элементам массива можно обращаться с помощью оператора [], где указываются индексы нужного элемента.
  Индексация начинается с нуля.
= NumPy позволяет выбирать сразу целые строки или столбцы с помощью оператора : и его продвинутой
  версии — начальный_индекс: конечный_индекс: шаг.
= Функции zeros, ones, full, random.rand, random.randint, identity и eye помогают быстро создать
  массивы любого размера с заполненными элементами.
= Все арифметические операции, которые доступны в python, применимы и к массивам NumPy. Главное —
  это то, что операции проводятся поэлементно.
= Для сложных операций, таких как вычисление производной, также есть свои функции.
= NumPy-массивы нельзя просто присвоить другой переменной, чтобы скопировать. Для этого существует
  функция copy. А чтобы поменять структуру данных, можно применить функции reshape, vstack и hstack.
= В NumPy есть дополнительные функции — например, чтение из файла с помощью genfromtxt и
  булевы выражения, которые позволяют выбирать элементы из набора данных по заданным условиям.


И вообще, приложение можно запускать НЕ ТОЛЬКО из командной строки, Но также непосредственно из среды
разработки приложения IDLE. То есть, из окна terminal (!). Важно, чтобы команда для запуска была корректна
(синтаксис) и адекватна (каталог):

C:\PythonDrom\Tests_2022\test_19_10_2023>python circleTest.py


Далее приведены ТРИ попытки запуска coverage с приложением:
1. Как оно есть (с закомментированной функцией goCircle и её вызовом)

import math

class Circle:
    def __init__(self, radius: float) -> None:
        if radius < 0:
            raise ValueError('The radius cannot be negative')

        self._radius = radius

    def area(self) -> float:
        return math.pi * math.pow(self._radius, 2)

    def perimeter(self) -> float:
        return 2 * math.pi * self._radius

# def goCircle(radius):
#     c = Circle(radius)
#     cArea = c.area()
#     cArea = round(cArea, 3)
#     cPerimeter = c.perimeter()
#     cPerimeter = round(cPerimeter, 3)
#     print(cArea, cPerimeter)
#
# goCircle(25)
__________________________________________________________________________
PS C:\PythonDrom\Tests_2022\test_19_10_2023> python -m coverage run circleTest.py
PS C:\PythonDrom\Tests_2022\test_19_10_2023> python -m coverage report
Name            Stmts   Miss  Cover
-----------------------------------
circleTest.py      10      5    50%
-----------------------------------
TOTAL              10      5    50%

2. С раскомментированной функцией goCircle её закомментированным вызовом

import math

class Circle:
    def __init__(self, radius: float) -> None:
        if radius < 0:
            raise ValueError('The radius cannot be negative')

        self._radius = radius

    def area(self) -> float:
        return math.pi * math.pow(self._radius, 2)

    def perimeter(self) -> float:
        return 2 * math.pi * self._radius

def goCircle(radius):
    c = Circle(radius)
    cArea = c.area()
    cArea = round(cArea, 3)
    cPerimeter = c.perimeter()
    cPerimeter = round(cPerimeter, 3)
    print(cArea, cPerimeter)

# goCircle(25)
__________________________________________________________________________
PS C:\PythonDrom\Tests_2022\test_19_10_2023> python -m coverage run circleTest.py
PS C:\PythonDrom\Tests_2022\test_19_10_2023> python -m coverage report
Name            Stmts   Miss  Cover
-----------------------------------
circleTest.py      17     11    35%
-----------------------------------
TOTAL              17     11    35%

3. С полностью раскомментированным приложением (класс, функция, выражение вызова)

import math

class Circle:
    def __init__(self, radius: float) -> None:
        if radius < 0:
            raise ValueError('The radius cannot be negative')

        self._radius = radius

    def area(self) -> float:
        return math.pi * math.pow(self._radius, 2)

    def perimeter(self) -> float:
        return 2 * math.pi * self._radius

def goCircle(radius):
    c = Circle(radius)
    cArea = c.area()
    cArea = round(cArea, 3)
    cPerimeter = c.perimeter()
    cPerimeter = round(cPerimeter, 3)
    print(cArea, cPerimeter)

goCircle(25)
__________________________________________________________________________
PS C:\PythonDrom\Tests_2022\test_19_10_2023> python -m coverage run circleTest.py
1963.495 157.08
PS C:\PythonDrom\Tests_2022\test_19_10_2023> python -m coverage report
Name            Stmts   Miss  Cover
-----------------------------------
circleTest.py      18      1    94%
-----------------------------------
TOTAL              18      1    94%

Как-то так...
